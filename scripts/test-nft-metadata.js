const hre = require("hardhat");
const { ethers } = require("hardhat");

async function main() {
    console.log("üé® TESTING NFT METADATA WITH CHAINLINK FUNCTIONS");
    console.log("======================================================================");
    
    try {
        const network = hre.network.name;
        const [deployer] = await ethers.getSigners();
        
        console.log(`üì° Network: ${network}`);
        console.log(`üë§ Deployer: ${deployer.address}`);
        console.log(`üí∞ Balance: ${ethers.formatEther(await ethers.provider.getBalance(deployer.address))} AVAX`);
        
        // Load deployed contracts
        const oracleDeployment = require("../deployments/avalancheFuji-oracle-deployment.json");
        const batchSystemDeployment = require("../deployments/avalancheFuji-batch-nft-system.json");
        
        const oracle = await ethers.getContractAt("CarbonVerificationOracle", oracleDeployment.contractAddress);
        const batchNFT = await ethers.getContractAt("BatchNFT", batchSystemDeployment.contracts.batchNFT.address);
        
        console.log(`üîó Oracle: ${oracleDeployment.contractAddress}`);
        console.log(`üé® BatchNFT: ${batchSystemDeployment.contracts.batchNFT.address}`);
        
        // ================================================================
        // PHASE 1: CHECK EXISTING CHAINLINK DATA
        // ================================================================
        console.log("\n" + "=" .repeat(50));
        console.log("üîç PHASE 1: CHECKING CHAINLINK FUNCTIONS DATA");
        console.log("=" .repeat(50));
        
        // Check existing credit and verification
        const creditId = 2; // From our previous test
        let credit, verificationData;
        
        try {
            credit = await oracle.getCarbonCredit(creditId);
            console.log(`‚úÖ Found carbon credit ID: ${creditId}`);
            console.log(`üìã Project: ${credit.projectId}`);
            console.log(`üìã Amount: ${ethers.formatUnits(credit.amount, 18)} tonnes`);
            console.log(`üìã Verified: ${credit.isVerified}`);
            
            // Get verification data
            const requestId = await oracle.creditToRequest(creditId);
            if (requestId !== ethers.ZeroHash) {
                verificationData = await oracle.getVerificationRequest(requestId);
                console.log(`\nüîó Chainlink Functions Data:`);
                console.log(`   Request ID: ${requestId}`);
                console.log(`   Fulfilled: ${verificationData.fulfilled}`);
                
                if (verificationData.fulfilled) {
                    console.log(`   üåü GS Project ID: ${verificationData.gsId}`);
                    console.log(`   üî• Available Credits: ${verificationData.availableForSale}`);
                    console.log(`   üìÖ Timestamp: ${verificationData.timestamp}`);
                    console.log(`   ‚úÖ Status: ${verificationData.verificationStatus}`);
                }
            } else {
                console.log("‚ö†Ô∏è  No Chainlink verification request found");
            }
        } catch (error) {
            console.log(`‚ö†Ô∏è  Credit ${creditId} not found:`, error.message);
            verificationData = null;
        }
        
        // ================================================================
        // PHASE 2: CHECK EXISTING BATCH NFT
        // ================================================================
        console.log("\n" + "=" .repeat(50));
        console.log("üé® PHASE 2: CHECKING BATCH NFT METADATA");
        console.log("=" .repeat(50));
        
        // Check if we have any existing BatchNFTs
        const nextBatchId = await batchNFT.nextBatchId();
        console.log(`üìä Next batch ID: ${nextBatchId}`);
        
        if (Number(nextBatchId) > 1) {
            // We have existing NFTs
            for (let i = 1; i < Number(nextBatchId); i++) {
                try {
                    const owner = await batchNFT.ownerOf(i);
                    console.log(`\nüé® BatchNFT #${i} owned by: ${owner}`);
                    
                    // Get batch data
                    const batchData = await batchNFT.getBatchData(i);
                    console.log(`üìã Project ID: ${batchData.projectId}`);
                    console.log(`üìã Total Credits: ${ethers.formatUnits(batchData.totalCredits, 18)}`);
                    console.log(`üìã Oracle Credit ID: ${batchData.oracleCreditId}`);
                    
                    // Get NFT metadata
                    try {
                        const tokenURI = await batchNFT.tokenURI(i);
                        console.log(`\nüîó NFT Metadata for BatchNFT #${i}:`);
                        
                        if (tokenURI.startsWith("data:application/json;base64,")) {
                            const base64Data = tokenURI.replace("data:application/json;base64,", "");
                            const jsonData = Buffer.from(base64Data, 'base64').toString('utf-8');
                            const metadata = JSON.parse(jsonData);
                            
                            console.log(`üìù Name: ${metadata.name}`);
                            console.log(`üìù Description: ${metadata.description}`);
                            console.log(`üìù Attributes:`);
                            
                            metadata.attributes.forEach(attr => {
                                const isChainlinkData = attr.trait_type.includes("GS Project ID") || 
                                                       attr.trait_type.includes("Available Credits") || 
                                                       attr.trait_type.includes("Last Updated") ||
                                                       attr.trait_type.includes("Verification Status");
                                
                                if (isChainlinkData) {
                                    console.log(`     üîó ${attr.trait_type}: ${attr.value} (FROM CHAINLINK FUNCTIONS)`);
                                } else {
                                    console.log(`     üìã ${attr.trait_type}: ${attr.value}`);
                                }
                            });
                        } else {
                            console.log(`üìã Token URI: ${tokenURI}`);
                        }
                    } catch (error) {
                        console.log(`‚ö†Ô∏è  Could not fetch metadata: ${error.message}`);
                    }
                    
                    // Check associated ProjectToken
                    const tokenAddress = await batchNFT.batchToTokenContract(i);
                    if (tokenAddress !== ethers.ZeroAddress) {
                        console.log(`\nü™ô Associated ProjectToken: ${tokenAddress}`);
                        
                        try {
                            const projectToken = await ethers.getContractAt("ProjectToken", tokenAddress);
                            const tokenName = await projectToken.name();
                            const tokenSymbol = await projectToken.symbol();
                            const totalSupply = await projectToken.totalSupply();
                            
                            console.log(`   Name: ${tokenName}`);
                            console.log(`   Symbol: ${tokenSymbol}`);
                            console.log(`   Total Supply: ${ethers.formatUnits(totalSupply, 18)}`);
                        } catch (error) {
                            console.log(`   ‚ö†Ô∏è  Could not fetch token info: ${error.message}`);
                        }
                    }
                    
                } catch (error) {
                    console.log(`‚ö†Ô∏è  BatchNFT #${i} not found or error: ${error.message}`);
                }
            }
        } else {
            console.log("üìù No BatchNFTs found yet");
        }
        
        // ================================================================
        // PHASE 3: DEMONSTRATE CHAINLINK INTEGRATION
        // ================================================================
        console.log("\n" + "=" .repeat(50));
        console.log("üîó PHASE 3: CHAINLINK FUNCTIONS INTEGRATION DEMO");
        console.log("=" .repeat(50));
        
        if (verificationData && verificationData.fulfilled) {
            console.log("üéØ CHAINLINK FUNCTIONS SUCCESS!");
            console.log("This demonstrates how real-time API data becomes NFT metadata:");
            
            console.log(`\nüìä Live data from Gold Standard API (via Chainlink):`);
            console.log(`   üåü Project ID: ${verificationData.gsId}`);
            console.log(`   üî• Available Credits: ${verificationData.availableForSale}`);
            console.log(`   üìÖ API Timestamp: ${verificationData.timestamp}`);
            console.log(`   ‚úÖ Verification: ${verificationData.verificationStatus === 1 ? 'VERIFIED' : 'PENDING'}`);
            
            console.log(`\nüé® This data is automatically included in NFT metadata as:`);
            console.log('   {');
            console.log('     "attributes": [');
            console.log(`       {"trait_type": "GS Project ID", "value": "${verificationData.gsId}"},`);
            console.log(`       {"trait_type": "Available Credits", "value": ${verificationData.availableForSale}},`);
            console.log(`       {"trait_type": "Last Updated", "value": "${verificationData.timestamp}"},`);
            console.log(`       {"trait_type": "Verification Status", "value": "Chainlink Verified"}`);
            console.log('     ]');
            console.log('   }');
            
            console.log(`\n‚úÖ KEY ACHIEVEMENT: NFT metadata is DYNAMIC and powered by Chainlink Functions!`);
            console.log(`   ‚Ä¢ Real-time carbon credit availability`);
            console.log(`   ‚Ä¢ Live project verification status`);
            console.log(`   ‚Ä¢ Current API timestamps`);
            console.log(`   ‚Ä¢ Decentralized data integrity`);
            
        } else {
            console.log("‚ö†Ô∏è  No fulfilled Chainlink verification found");
            console.log("üìù To see the full integration:");
            console.log("   1. Run: npx hardhat run scripts/test-chainlink-integration.js --network avalancheFuji");
            console.log("   2. Wait for Chainlink callback");
            console.log("   3. Run this script again to see NFT metadata");
        }
        
        // ================================================================
        // PHASE 4: SUMMARY
        // ================================================================
        console.log("\n" + "=" .repeat(50));
        console.log("üìã SUMMARY: CHAINLINK FUNCTIONS AS NFT METADATA");
        console.log("=" .repeat(50));
        
        console.log("üîó System Architecture:");
        console.log("   1. CarbonVerificationOracle uses Chainlink Functions");
        console.log("   2. Fetches real-time data from Gold Standard API");
        console.log("   3. BatchNFT metadata includes this live data");
        console.log("   4. NFT attributes update with each verification");
        
        console.log("\nüéØ Core Innovation:");
        console.log("   ‚Ä¢ NFT metadata is NOT static JSON");
        console.log("   ‚Ä¢ Powered by real-time Chainlink Functions data");
        console.log("   ‚Ä¢ Reflects current carbon credit availability");
        console.log("   ‚Ä¢ Maintains decentralized verification integrity");
        
        console.log("\n‚úÖ TEST COMPLETE!");
        
    } catch (error) {
        console.error("‚ùå Test failed:", error);
        process.exit(1);
    }
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    }); 